[TOC]
# OC语法
## 基础知识

### main

1. main函数是程序入口，一个程序只能有一个main()函数，需要有一个整型返回值（事实上返回值int可以省略，但是这并不代表不返回值，而是默认为int；我们也可以在main()函数中不提供return，这是因为c语言语法要求不够严格）。
* main函数总是返回0，0代表成功终止程序，1代表错误终止。
也可以理解为：
	* 0（false）：无错误返回
	* 1（true）：有错误返回

2. \#include是预处理指令，用于包含指定文件（注意在编译前即处理），它实际做的工作就是把对应文件复制到指定的位置； 包含的内容可以是任何类型的文件，而不仅仅是.h文件；
> \#include 包含文件时有两种方式：使用<>和””。区别就是<>包含只会查找编译器库函数文件，因此适用于包含库函数；而“”包含则首先查找程序当前目录，如果没有找到则查找库函数路径，因此适用于自定义文件；
```c
#include <stdio.h>

void showMessage(){
    printf("Hello, World!\n");
}

int main(int argc, const char * argv[]) {
    // insert code here...
    showMessage()
    return 0;
}
```
> 上面的showMessage函数必须写在main()函数上面，如果写在下面则必须在main()函数之前声明；

### 运行过程
![3-1-1](./img/3-1-1.png)

C语言的运行分为两大步：编译和链接

* 编译：编译阶段会将对应的xxx.c源文件（ASCII格式）编译成目标文件xxx.obj，它是二进制格式（当然一般我们会有多个.c文件，也就会生成多个对应的.obj）；在编译之前要进行预处理（例如#include指令），在编译的同时还要进行语法检查；生成的.obj文件并不能单独执行，因为各个.obj之间是有关联的，而且他们还各自引用了C语言库函数；

* 链接：链接的过程就是将各个.obj文件和C语言库函数一起组合生成一个可执行文件的过程；

#### 扩展

我们通常将一个子操作分为两个文件：.c文件和.h文件。在.c文件中实现对应的函数，在.h中进行函数声明，这样只要在主函数上方包含对应的头文件就可以将子操作分离出来而且不用考虑顺序问题。如下所示：

message.h

```c
#ifndef message_h
#define message_h

#include <stdio.h>

void showMessage();

#endif /* message_h */
```

message.c

```c
#include "message.h"

void showMessage(){
    printf("Hello world!\n");
}
```

> 注意：message对应的.c和.h文件名完全可以不相同，但是出于规范的目的我们还是取相同的文件名

> **思考：如果我们不分成两个文件，直接在主函数文件中包含message.c是否也可以正常运行呢？答案是否定的。**
>
> **原因是main.c中\#Include指令会把message.c复制到main.c中。编译后的main.obj已包含showMessage函数。因此在main.obj和 message.obj在链接时会发现main.obj中已经有message.obj中定义的showMessage函数，抛出“标示符重复”的错误。**

### 数据类型

![数据类型](./img/3-1-2.png)

#### 类型修饰符（限定符）

从上图我们可以清晰的看到C语言的数据类型结构，对于基本类型我们还有一些类型修饰符

* short 短型 ：修饰int、double

* long 长型：修饰int、double

* signed 有符号型,修饰int、char

* unsigned 无符号型，修饰int、char

> 1. 这些修饰符经常用来修饰int型，**在修饰int类型时int可以省略**；
> 2. short和long会改变int型的长度，不同编译器项长度不相同，但是short长度不大于int，int长度不大于long；
> 3. signed、unsigned不改变类型长度，仅仅表示最高位是否为符号位，unsigned表示大于等于0的正数；


![字符长度](./img/3-1-3.png)

> **注意：**
>
> **1. char类型是最小的数据类型单位，在任何类型的编译器下都是占用1个字节，char类型的变量赋值可以直接赋值等于某个字符也可以赋值为整数（对应的ASCII值）;**
>
> **2. 可以使用两个long来修饰一个整形（就是经常使用的8字节的整形long long），但是两个long不能修饰double而且也不存在两个short，否则编译警告;**
>
> **3. 一个浮点型常量如果后面加上f编译器认为它是float类型，否则认为double类型，例如10.0是double类型，10.0f是float类型。**
```c
unsigned x; //无符号32位整数
signed y; //有符号16位整数
char a;  //8位
short b; //通常是16位（视平台而定）
int c;   //通常是32位（视平台而定）
long d;  //32位或64位（视平台而定）
long long e; //64位
```

### 运算符

C语言中有34中运算符，同C#、Java等语言没有太大的区别，这里指列出一些注意事项：

1. 关系运算符为真就返回1，为假就返回0；在条件语言中非0即真（负数、正数均为真），只有0为假 ；

2. C语言可以不保存关系运算符的值 ；

3. 逗号表达式最终的值是最后一个表达式的值；

例子：
```c
#include <stdio.h>


int main(int argc, const char * argv[]) {
    int a=2>1,b=2<1,c=99,d=0;
    int f=0,g=0,h=0,e=(f=3,g=4,h=5);
    
    a>0;//没有保存运算结果
    
    printf("%d,%d\n",a,b);//结果：1,0
    
    if(c){//可以通过
        printf("true.\n");
    }
    if(d){//无法通过
        printf("false\n");
    }
    
    printf("%d\n",e);//结果：5
    return 0;
}
```

### 常用函数

#### printf()函数

printf()函数用于向标准输出设备输出数据，配合格式符可以完成强大的输出功能。

![字符串格式化](./img/3-1-5.png)

```c
#include <stdio.h>


int main(int argc, const char * argv[]) {
    int a=16;
    float b=79.3f;
    printf("[a=%4d]\n",a);
    printf("[a=%-4d]\n",a);
    printf("[b=%10f]\n",b);
    printf("[b=%.2f]\n",b);
    printf("[b=%4.2f]\n",b);
    return 0;
}
```

结果如下：

```c
[a=  16]
[a=16  ]
[b= 79.300003]
[b=79.30]
[b=79.30]
Program ended with exit code: 0
```

#### scanf()函数

1. 参数接收以回车进行结束操作；
2. 如果需要接收多个参数，多个参数之间的分隔符是任意的，但是如果分隔符是“空格”则实际输入的时候分隔符可以使空格、tab和回车（最后一个回车认为是结束符）

```c
#include <stdio.h>


int main(int argc, const char * argv[]) {
    int a,b,c;
    scanf("%d,%d,%d",&a,&b,&c);//此时需要输入：1,2,3 然后回车
    printf("a=%d,b=%d,c=%d\n",a,b,c);
    return 0;
}

```











### 局部变量、帧（frame）、栈（stack）

1. 局部变量保存在函数的帧中，函数执行完，帧销毁
2. 程序中使用栈来描述帧在内存中的存储地点，执行函数时，函数的帧会在栈的顶部被创建出来。函数结束，帧退出栈。
### 全局变量，静态变量
1. 全局变量：全局变量可以就可以作用于该程序的所有的源文件。其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量，因此全局变量容易造成混淆
2. 静态变量它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
```c
#include <stdio.h>
#include "test2.h"

extern char *qjbl;//全局变量需要extern关键字再次声明才可使用

int main(int argc, const char * argv[]) {
    // insert code here...
    printf("Hello, World!\n");
    printf("%s", qjbl); //test1.h中的q静态变量
    printf("%s", jtbl); //test2.h中的q静态变量
    return 0;
}
```










### 格式化字符串

* %d：十进制整数
* %s：字符串（char，NSString是对象）
* %o：八进制（octol）
* %x：十六进制（hexadecimal）
* %u：无符号十进制整数
* %f：浮点数
* %e：浮点数科学计数法
* %p：内存地址格式说明，一般内存地址都已十六进制输出
* %zu：数据类型大小
* %@：输出对象的描述信息
* 

> 1. 在%和转换字符间加入==l（long）或者ll（long long）==，指明是大整数数据类型，如：%ld、%lo、%lx
> 2. 通过在%和f或者e之间加入小数点和数字来指定浮点数小数位数，如：%.2f（两位小数）, %.2e（两位小数科学计数法）


### 数字
* UInt32：无符号32位整数；
* SInt16：有符号16位整数


### 变量
1. NSInteger（有符号）、NSUInteger（无符号）可以在32位和64位系统中通用的数字类型。printf这两种类型时，需要转换为long型，如：
```c
    NSInteger x = -5;
    NSUInteger y = 6;
    printf("Here they are: %ld, %lu", (long)x, (unsigned long)y)
```

### 方法
1. abs(), labs()：前者计算int型绝对值、后者计算long型绝对值，需要include <stdlib.h>
2. include <math.h>使用数学代码库。
3. readline()：获取用户输入，需要引入代码库；libreadline.tbd
4. atoi()：将字符串转为整数，如：
```c
int num = "23" //出错

int num = atoi("23") //正确

int num = atoi("abc") //记过为0
```
> 如果字符串无法转为int，则返回0

5. sizeof()：得到某个数据类型的大小，结合指针地址使用可以获取数据在内存中的结束地址。
    * sizeof()会返回一个类型为size_t的数，与之对应的格式说明符为%zu
    * sizeof()传入的参数还可以是变量
```c
int i = 7;
int *addressOfI = &i
printf("An int is %zu\n", sizeof(int)); //结果为：AN int is 4

printf("A pointer is %zu\n", sizeof(int *));//结果为：A pointer is 8

printf("A pointer is %zu\n", sizeof(addressOfI));//结果为：A pointer is 8
```

6. modf()：调用该方法时传入double类型的数与指针地址，会返回小数部分，并且将整数部分保存到指针地址中。
    * 需要include <math.h>
    * 这种参数传递方式称为==通过引用传递==


### 指针
> 可以通过变量存储指针地址，通过指针地址变量可以快速传递大数据所在内存地址

1. 在变量前面添加&运算符，来获得变量的内存地址
2. 有三种用途：
    * 声明指针，使变量指向内存地址；
    * 访问保存在内存地址中的数据；
    * 用在赋值表达式的左侧，将数据保存在指定的地址；
```c
int i = 7;
int *addressOfI = &i; //声明指针，使变量指向内存地址
printf("i stores its value at %p\n", &addressOfI);
//输出结果为：i stores its value at 0x7fff5fbff65c

printf("the int stored at addressofi is %d\n", *addressOfI); //访问保存在内存地址中的数据
//输出结果为：the int stored at addressofi is 7

*addressOfI = 88; //用于赋值表达式左侧，将88保存到指定的内存地址，因为变量i也指向相同地址，所以i的值为：88
printf("Now i is %d\n", i);
//输出结果为：Now i is 88
```
3. NULL
    * objective-c中nil等价于NULL，均表示空指针；
    * NULL就是0

> 某些情况需要使用“空”指针，不指向任何地址。换句话说，有一个指针变量，要给这个变量附上一个值，用来说明此变量没指向任何地址。NULL就是这样一个值，用来说明这个指针变量未指向任何地址。

### 结构（structure）
1. 使用结构（struct），来定义多个数据的组合体，类似Java中的pojo
2. 定义结构的两种方式
  * sturct关键字，定义的时候都要写struct关键字
  * typedef关键字
```c
/// 1.sturct关键字，定义的时候都要写struct关键字
struct Person {
    float height;
    int weight;
}

int main(int argc, const char * argv[]){
    struct Person leron; //声明Person变量时需要struct关键字
    leron.height = 1.80;
    leron.weight = 75;
}

/// 2.typedef关键字
typedef struct {
    float height;
    int weight;
}Person；

int main(int argc, const char * argv[]){
    Person leron; //声明Person变量时不需要struct关键字
    leron.height = 1.80;
    leron.weight = 75;
}
```

### 栈 & 堆
1. 栈：调用函数时系统自动分配，并在函数结束时自动释放。
2. 堆：特定内存区域，与栈是分开的。通常连续内存区域叫做：缓冲区。缓冲区来自堆，独立于任何函数的栈，因此可以在多个函数中使用。
> 在C中可以通过malloc()函数得到一块内存缓冲区。当程序不再使用缓冲区时，可以使用free()函数释放内存，还给堆

```c
#include <stdio.h>
#include <stdlib.h>

void get1000floatBuffer(){
    float *startOfBuffer; //声明缓冲区指针变量
    
    startOfBuffer = malloc(1000 * sizeof(float));//获取可以存放1000个float类型变量的内存大小的缓冲区
    
    //。。。使用缓冲区。。。
    
    free(startOfBuffer);//释放缓冲区
    
    startOfBuffer = NULL;//将指针变量赋值为NULL
}

typedef struct {
    float height;
    int weight;
}Person;

float bodyMassIndex(Person *p){
    return p->weight / (p->height * p->height);
}

int main(int argc, const char * argv[]) {
    // insert code here...
    //get1000floatBuffer();
    
    //为Person分配缓冲区
    Person *leron = (Person *)malloc(sizeof(Person));
    printf("leron buffer address: %p\n", &leron);
    
    //为数据结构赋值
    //->函数作用：先获取指针leron指向的数据结构，然后返回该结构的成员变量
    leron->height = 1.8;
    leron->weight = 75;
    
    float leronBMI = bodyMassIndex(leron);
    printf("leron has a BMI of %f\n", leronBMI);
    
    free(leron);
    
    leron = NULL;
    
    return 0;
}
```