# 架构学习
## MVC

### 结构示意图

![5-1-1](.\img\5-1-1.png)



## MVP

### 结构示意图

![5-2-1](.\img\5-2-1.png)



## MVVM



### google官方MVVM框架讲解

google官方发布了MVVM的正式库。官方的正式MVVM库主要包括下面四个：

![5-3-1](.\img\5-3-1.png)
1. **ViewModel**是MVVM结构中的一个组件，其他的三个都是辅助性质的。
2. **lifecycles** 就是处理UI界面的生命周期，在26版本以后的Support库中，AppCompatActivity和SupportActivity中都实现了LifecycleOwner，内部已经对UI界面的生命周期做了处理了。
3. **LiveData**是一个抽象类，我们可以存放UI页面需要的数据，就是把数据包装在LiveData中了，我们可以观测LiveData中的数据变化，但是LiveData是跟UI的生命周期关联的，当UI页面销毁了，LiveData的数据变化回调是不会执行的。
4. **Room** 就是一个sqlite数据持久化库，我们也可以使用别的ORM库。

### MVVM架构优势
#### 结构示意图
![5-3-1](.\img\5-3-2.png)

看上图**Model**和**View**是不会发生关系的，**ViewModel**是把View和Model关联起来的加工厂：

![5-3-3](.\img\5-3-3.png)

#### MVVM优势总结
1. **View**和**Model**双向绑定，一方的改变都会影响另一方，开发者不用再去手动修改UI的数据。
2. 不需要**findViewById**也不需要**butterknife**，不需要拿到具体的View去设置数据绑定监听器等等，这些都可以用**DataBinding**完成。
3. **View**和**Model**的双向绑定是支持生命周期检测的，不会担心页面销毁了还有回调发生，这个由**lifeCycle**完成。
4. 不会像**MVC**一样导致Activity中代码量巨大，也不会像**MVP**一样出现大量的View和Presenter接口。项目结构更加低耦合。
5. 更低的耦合把各个模块分开开发，分开测试，可以分给不同的开发人员来完成。

### MVVM组件化示例项目架构分析

#### 模块与工程依赖关系图

![5-3-4](.\img\5-3-4.png)

#### Android Studio工程结构

![5-3-5](.\img\5-3-5.png)

#### 各模块之间的关系

1. **lib_opensource** ：第三方build.gradle依赖，本项目主要有support、lifecycle、room、fresco、retrofit、okhttp、RxJava、ARouter这些。
2. **lib_coremodel**: 存放MVVM中的Model和ViewModel两个模块，就是数据的处理和数据与UI页面的绑定。依赖lib_opensource库。
3. **lib_common** : 公共库，主要有各种base，各种ui组件，自定义组件，公用的Activity、公用的Fragment，和公用的utils等等。依赖lib_coremodel库。
4. **module_girls** : 妹子功能模块，可以在library和application之间切换，自己可以是一个app也可以成为别的app的一个组件模块。组件化编译时为app，反之为module。
5. **module_news** : 新闻功能模块，可以在library和application之间切换，自己可以是一个app也可以成为别的app的一个组件模块。组件化编译时为app，反之为module。
6. **app_universal** : 定制版本的app，组件化编译时 module_girls和module_news为app，所以不能把这两个作为module加进来编译，所以组件化编译时app_universal要依赖lib_common库，反之就可以把 module_girls和module_news作为module加进来编译。
7. **app_specific** : 定制版本的app，组件化编译时 module_girls和module_news为app，所以不能把这两个作为module加进来编译，所以组件化编译时app_specific要依赖lib_common库，反之就可以把 module_girls和module_news作为module加进来编译。

### ARouter串联各个模块

ARouter典型应用
* 从外部URL映射到内部页面，以及参数传递与解析
* 跨模块页面跳转，模块间解耦
* 拦截跳转过程，处理登陆、埋点等逻辑
* 跨模块API调用，通过控制反转来做组件解耦

### 组件化编译和非组件化编译切换









## 总结

### MVP与MVC的区别（阅读时请不断对比上面的两张图）
1. Activity职责不同，Activity在MVP中是View层，在MVC中是Controller层，这是MVC和MVP很主要的一个区别，可以说Android从MVC转向MVP开发也主要是优化Activity的代码，避免Activity的代码臃肿庞大。

2. View层不同，MVC的View层指的是XML布局文件或者是用Java自定义的View，MVP的View层是Activity或者Fragment。使用传统的MVC，其中的View，对应的是各种Layout布局文件，但是这些布局文件中并不像Web端那样强大，能做的事情非常有限。MVP的View层Activity在实际项目中，随着逻辑的复杂度越来越大，Activity臃肿的缺点仍然体现出来了，因为Activity中还是充满了大量与View层无关的代码，比如各种事件的处理派发，就如MVC中的那样View层和Controller代码耦合在一起无法自拔。

3. 控制层不同，MVC的控制层是Activity，或者是Fragment，Controller对应的是Activity，而Activity中却又具有操作UI的功能，我们在实际的项目中也会有很多UI操作在这一层，也做了很多View中应该做的事情，当然Controller层Activity中也包含Controller应该做的事情，比如各种事件的派发回调，而且在一层中我们会根据事件再去调用Model层操作数据，所以这种MVC的方式在实际项目中，Activity所在的Controller是非常重的，各层次之间的耦合情况也比较严重，不方便单元测试。MVP的控制层是Presenter，里面没有很多的实际东西，主要是做Model和View层的交互。

4. 关系链不同，MVP中Model层与View是没有关系的，彼此不会通讯和操作，Model与View的通讯都是Presenter层来传达的。但是在MVC中，Model层和View是曾在交互的。比如我们自定义的View控件里面肯定是要使用Model的数据的，View也要根据不同的Model数据做出不同的展现！这点尤其是体现在自定义的View中，自定义View需要设置数据，用户操作了自定义控件需要改变数据，View要操作Model怎么办？有人说把Controller传到自定义的View啊，现实是不可能没一个自定义View都去持有Controller的引用，其实在MVP中就不会这么尴尬，接口就可以完成。

5. 适用范围不同，在Android中，MVP和MVC都用自己的适用情况，使用MVP可以更好的解耦三大模块，模块之间比较清晰，也很方便使用MVP来组件化架构整体项目。但是MVC也是有用武之地的，在组件化的Module或者中间件我们可以使用MVC来做，Module或者中间件不会存在很复杂的View层，使用MVC可以更加方便我们实现功能。

6. 交互方式不同，MVP中通讯交互基本都是通过接口的，MVC中的通讯交互很多时候都是实打实的调用对象的方法，简单粗暴！

7. 实现方法不同 ，MVC和MVP的Model几乎一样的，都是处理数据，只要不在Activity或者Fragment中请求数据，其他的所有控制都放在Activity或者Fragment中，这样写就基本是MVC的模式，这样写不麻烦，但是很容易把Activity写出上万行代码。用MVP的时候我们需要写很多View和Presenter接口来实现模块之间的通讯，会增加很多类。

网络流行对比段子：
* 相同点： 
	* 优点： 
		1. 降低耦合度 
		2. 模块职责划分明显 
		3. 利于测试驱动开发 
		4. 代码复用 
		5. 隐藏数据 
		6. 代码灵活性 
	* 缺点： 
		1. 额外的代码复杂度及学习成本。

* 不同点： 
	* MVP模式： 
		1. View不直接与Model交互，而是通过与Presenter交互来与Model间接交互 
		2. Presenter与View的交互是通过接口来进行的，更有利于添加单元测试 
		3. 通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑，业务相似的时候也可以多同个View共享一个Presenter。 
	* MVC模式： 
		1. View可以与Model直接交互 
		2. Controller是基于行为的，并且可以被多个View共享 
		3. Controller可以负责决定显示哪个View